---
title: Терминология памяти
author: MSEdgeTeam
ms.author: msedgedevrel
ms.date: 04/03/2020
ms.topic: article
ms.prod: microsoft-edge
keywords: Microsoft EDGE, веб-разработка, инструменты для F12, Devtools
ms.openlocfilehash: e3373cf1475ec0eeaabcebf1a7f49505c7a3c1bb
ms.sourcegitcommit: 50991a04c18283a8890ae33fcc3491c0476c7684
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/30/2020
ms.locfileid: "10611729"
---
<!-- Copyright Meggin Kearney 

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. -->





# Терминология памяти   



В этом разделе описаны распространенные термины, используемые при анализе памяти, и применимы различные средства профилирования памяти для разных языков.  

Описанные здесь положения и понятия относятся к [панели память][DevtoolsMemoryProblemsHeapSnapshots].  Если вы когда-либо работали с приложением Java, .NET или какой-либо другой профилировщиком памяти, это может быть новым.  

## Размеры объектов  

Рассматривайте память как графы с примитивными типами \ (например, числа и строки \) и Objects \ (ассоциативные массивы \).  Он может наглядно представлять собой граф с числом взаимосвязанные точек, как описано ниже.  

> ##### Рис. 1  
> Визуальное представление памяти  
>![Визуальное представление памяти][ImageThinkGraph]  

Объект может содержать память двумя способами:  

*   Непосредственно объектом.  
*   Неявным образом, сохраняя ссылки на другие объекты и предотвращая автоматическое удаление этих объектов сборщиком мусора (**GC** для коротких \).  

При работе с [панелью памяти][DevtoolsMemoryProblemsHeapSnapshots] в DevTools \ (средство для изучения проблем с памятью, обнаруженных в разделе "память" \), вы можете просмотреть несколько разных столбцов данных.  Два из них выделены **неполной** и **сохраненной размерностью**, но что они представляют?  

> ##### Рисунок 2  
> Неглубокий и сохраненный размер  
>![Неглубокий и сохраненный размер][ImageShallowRetained]  

### Неглубокий размер  

Это размер памяти, занимаемой объектом.  

Типичные объекты JavaScript зарезервированы для их описания и для хранения непосредственных значений.  Обычно массивы и строки можно использовать для значительного небольшого размера.  Однако строки и внешние массивы часто имеют основное хранилище в памяти обработчика, предоставляя только небольшой объект-оболочку в куче JavaScript.  

Память рендеринга — это вся память процесса, на котором выводится проверенная страница: собственная память + JS-память кучи Page + JS для всех выделенных сотрудников, запущенных страницей.  Тем не менее, даже небольшой объект может косвенно хранить большое количество памяти, предотвращая удаление других объектов с помощью автоматического процесса сборки мусора.  

### Сохраненный размер  

Это размер памяти, которая освобождается после удаления объекта вместе с зависимыми объектами, которые были сделаны недостижимыми из **корней сборщика мусора** \ (корни GC \).  

**Корни сборщика мусора** \ (корни GC \) состоят из **дескрипторов** , созданных с помощью локальных и глобальных данных, при создании ссылки из машинного кода на объект JavaScript за пределами V8.  Все подобные дескрипторы могут быть найдены в снимке кучи в разделе **корни GC**  >  , которые**управляют** **GC roots**  >  **глобальными дескрипторами**областей и корней GC.  Описание дескрипторов в этой документации без подробностей о реализации браузера может быть запутанным.  Как корни сборщика мусора, так и дескрипторы — это не то, что вам нужно беспокоиться.  

Существует множество внутренних корней GC, большинство из которых не являются интересными для пользователей.  С точки зрения приложений существуют следующие типы корней.  

*   Глобальный объект Window \ (в каждом интернет-кадре).  В снимках кучи есть поле расстояния, представляющее собой число ссылок на свойства в кратчайшем пути хранения из окна.  
*   Дерево документов DOM, состоящее из всех исходных узлов DOM, которые можно получить, обходимым документом.  Не все узлы могут иметь оболочки JS, но если на нем есть обертка, она действует, пока документ активен.  
*   Иногда объекты могут храниться контекстом отладчика на панели **источники** и на **консоли** (например, после вычисления консоли).  Создание моментальных снимков кучи с помощью очищенной **консоли** и без активных точек останова в отладчике на панели « **источники** ».

>[!TIP]
> Очистите панель **консоли** , запустив `clear()` и деактивируйте точки останова на панели « **источники** », прежде чем делать снимок кучи на [панели «память»][DevtoolsMemoryProblemsHeapSnapshots].

Граф памяти начинается с корневого элемента, который может представлять собой `window` объект браузера или `Global` объект модуля Node. js.  Нельзя управлять тем, как этот корневой объект собирается сборщиком мусора (НОД).  

> ##### Рисунок3  
> Вы не можете управлять тем, как корневой объект собирается сборщиком мусора \ (НОД \).  
>![Вы не можете управлять тем, как корневой объект собирается сборщиком мусора (НОД).][ImageDontControl]  

В корне нет доступа к собранию мусора \ (НОД \).  

> [!NOTE]
> Столбцы " [неглубокий размер](#shallow-size) " и " [сохраненный размер](#retained-size) " представляют данные в байтах.  

## Дерево сохраненных объектов  

Куча — это сеть взаимосвязанные объектов.  В математическом мире эта структура называется **графиком** или графиком памяти.  Диаграмма строится на основе **узлов** , которые соединены с помощью **краев**, оба из которых задаются метками.  

*   Для **узлов** \ (или **объектов**\) задана метка с использованием имени функции- **конструктора** , которая использовалась для их построения.  
*   **Края** помечены с использованием имен **свойств**.  

Сведения [о том, как записать профиль с помощью профилировщика кучи][DevtoolsMemoryProblemsHeapSnapshots].  Некоторые из глазных вещей, которые можно увидеть в записи снимка [кучи на][DevtoolsMemoryProblemsHeapSnapshots] [рисунке 4](#figure-4) , включают расстояние: расстояние от корня СБОРЩИКА мусора \ (GC \).  Если почти все объекты одного и того же типа находятся на одном и том же расстоянии, то это может потребоваться для исследования.  

> ##### Рисунок4  
> Расстояние от корня  
>![Расстояние от корня][ImageRoot]  

## Лидеры  

Лидерские объекты состоят из древовидной структуры, так как у каждого объекта есть только один лидер.  У лидера объекта могут отсутствовать прямые ссылки на объект, который он является лидером; Это значит, что дерево лидера не является деревом графа.  

На [рисунке 5](#figure-5):  

*   Узел 1, являющийся узлом 2  
*   Узел 2 — это узлы 3, 4 и 6  
*   Узел 3 является узлом 5  
*   Узел 5 лидеры в узле 8  
*   Узел 6, являющийся узлом 7  

> ##### Рисунок 5  
> Структура дерева (лидера)  
>![Структура дерева (лидера)][ImageDominatorsSpanning]  

На [рис. 6](#figure-6)Node `#3` — это лидер `#10` , но он `#7` также существует в каждом простом пути от сборщика мусора \ (GC \) to `#10` .  Таким образом, объект B является лидером объекта A, если в каждом простом пути от корня к объекту A есть B.  

> ##### Рисунок6  
> Анимированный лидеровый свет  
>![Анимированный лидеровый свет][ImageDominators]  

## Специальные V8  

При профилировании памяти полезно понять, почему снимки кучи выглядят определенным образом.  В этом разделе описаны некоторые связанные с памятью разделы, в частности соответствующие **виртуальной машине V8 JavaScript** \ (V8 VM или VM \).  

### Представление объекта JavaScript  

Существуют три простых типа.  

*   Числа \ (например `3.14159...` \)  
*   Логические значения \ ( `true` или `false` \)  
*   Строки \ (например `"Werner Heisenberg"` \)  

Примитивы не имеют ссылки на другие значения и всегда Leafs или оконечными узлами.  

**Числа** можно хранить следующим образом:  

*   немедленные 31-разрядные целые значения, называемые **маленькими целыми числами** (**SMI**s \), или  
*   объекты кучи, которые называются **номерами кучи**. Номера куч используются для хранения значений, которые не помещаются в форму SMI (например, **Double**), или при необходимости **упаковки**значения, например для установки свойств.  

**Строки** можно хранить в одном из следующих вариантов:  

*   **куча ВМ**или
*   внешний в **памяти обработчика**.  **Объект-оболочка** создается и используется для доступа к внешнему хранилищу, в котором, например, сохраняются источники сценариев и другое содержимое, полученное из веб-сайта, а не копируется в кучу ВМ.

Память для новых объектов JavaScript выделяется из выделенной кучи JavaScript \ (или **кучи ВМ**).  Эти объекты управляются сборщиком мусора в V8 и, таким образом, остаются в активном состоянии, так как есть хотя бы одна строгая ссылка на них.  

Все, что не входит в кучу JavaScript, называется **неуправляемым объектом**.  Собственные объекты, в отличие от объектов кучи, не управляются сборщиком мусора V8 в течение всего времени существования, и к ним можно получить доступ только из JavaScript с помощью объекта-оболочки JavaScript.  

**Строка "минус** " — это объект, который содержит пары строк, которые хранятся, а затем объединены и являются результатом сцепления.  Присоединение к **строке** с ненужным содержимым будет выполняться только по мере необходимости. Примером может быть необходимость создания подстроки присоединенной строки.

Например, если вы выполняете сцепление `a` `b` , вы получаете строку, `(a, b)` представляющую результат сцепления.  Если позднее вы объедините `d` этот результат, вы получите еще одну **строку с недостатком** `((a, b, d)` .  

**Массив** — объект с числовыми ключами. **Массивы** широко используются в виртуальной машине V8 для хранения больших объемов данных. Наборы пар "ключ-значение", например словарей, заархивированы с помощью **массивов**.  

Типичный объект JavaScript хранится только в одном из двух типов **массивов** :  

*   именованные свойства и  
*   числовые элементы  

При наличии небольшого количества свойств эти свойства хранятся внутри объекта JavaScript.  

**Map** — это объект, который описывает как вид объекта, так и макет. Например, карты используются для описания неявных иерархий объектов для [быстрого доступа к свойствам][V8FastProperties].  


### Группы объектов  

Каждая группа **собственных объектов** состоит из объектов, которые содержат взаимные ссылки друг на друга.  Рассматривайте, например, поддерево DOM, в котором каждый узел имеет ссылку на относительный родительский объект и ссылки на следующий дочерний элемент и следующий одноуровневый элемент, создавая подключенную диаграмму.  Обратите внимание на то, что собственные объекты не представлены в куче JavaScript, поэтому объекты машинного кода имеют нулевой размер. Вместо этого создаются объекты-оболочки.  

Каждый объект-обертка содержит ссылку на соответствующий собственный объект для перенаправления команд в нее.  В свою очередь, Группа объектов содержит объекты-оболочки.  Однако это не создает несобираемого цикла, так как сборщик мусора (GC \) достаточно интеллектуальный для освобождения групп объектов, оболочки которых больше не упоминаются. Но при невозможности освобождения одной обертки она содержит всю группу и связанные с ней оболочки.  

<!--## Feedback   -->  



<!-- image links -->  

[ImageThinkGraph]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-thinkgraph.msft.png "Рисунок 1: визуальное представление памяти"  
[ImageShallowRetained]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-shallow-retained.msft.png "Рисунок 2: неглубокий и сохраненный размер"  
[ImageDontControl]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-dontcontrol.msft.png "Рис. 3. Вы не можете управлять тем, как корневой объект собирается сборщиком мусора (НОД)."  
[ImageRoot]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-root.msft.png "Рисунок 4: расстояние от корня"  
[ImageDominatorsSpanning]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-dominatorsspanning.msft.png "Рисунок 5: дерево с лидером в структуре"  
[ImageDominators]: /microsoft-edge/devtools-guide-chromium/media/memory-problems-dominators.msft.gif "Рисунок 6: Иллюстрация подвижного лидера"  

<!-- links -->  

[DevtoolsMemoryProblemsHeapSnapshots]: /microsoft-edge/devtools-guide-chromium/media/memory-problems/heap-snapshots "/microsoft-edge/devtools-guide-chromium/media/memory-problems"  

[V8FastProperties]: https://v8.dev/blog/fast-properties "Быстрые свойства в V8 | V8"  

> [!NOTE]
> Части этой страницы представляют собой изменения, основанные на работе, созданной и [предоставленной компанией Google][GoogleSitePolicies] и использованными в соответствии с условиями, описанными в [лицензии Creative Commons 4,0 международная лицензия][CCA4IL].  
> Исходная страница будет найдена [здесь](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101) и была написана с помощью [Meggin Kearney][MegginKearney] \ (технический редактор \).  

[![Лицензия Creative Commons][CCby4Image]][CCA4IL]  
Эта работа предоставляется в рамках международной лицензии [Creative Commons Attribution 4.0 International License][CCA4IL].  

[CCA4IL]: https://creativecommons.org/licenses/by/4.0  
[CCby4Image]: https://i.creativecommons.org/l/by/4.0/88x31.png  
[GoogleSitePolicies]: https://developers.google.com/terms/site-policies  
[KayceBasques]: https://developers.google.com/web/resources/contributors/kaycebasques  
[MegginKearney]: https://developers.google.com/web/resources/contributors/megginkearney
