---
description: В этом разделе описываются общие термины, используемые при анализе памяти, и применимы к различным средствам профилинга памяти для разных языков.
title: Терминология памяти
author: MSEdgeTeam
ms.author: msedgedevrel
ms.date: 02/12/2021
ms.topic: article
ms.prod: microsoft-edge
keywords: microsoft edge, веб-разработка, инструменты f12, средства разработчика
ms.openlocfilehash: 1579374be29f0f419ded3bf88f5dea284f0bbb1a
ms.sourcegitcommit: 6cf12643e9959873f8b5d785fd6158eeab74f424
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2021
ms.locfileid: "11397792"
---
<!-- Copyright Meggin Kearney 

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. -->

# <a name="memory-terminology"></a>Терминология памяти  

В этой статье описываются общие термины, используемые в анализе памяти, и применимы к различным средствам профилинга памяти для разных языков.  

Термины и понятия, описанные здесь, относятся к панели [Памяти.][DevtoolsMemoryProblemsHeapSnapshots]  Если вы когда-либо работали с Java, .NET или другим профилем памяти, то эта статья может быть обновлением.  

## <a name="object-sizes"></a>Размеры объектов  

Подумайте о памяти как о графике с примитивными типами \(например, числами и строками\) и объектами \(ассоциативными массивами\).  Он может отображаться как график со многими взаимосвязанными точками, такими как следующая фигура.  

:::image type="complex" source="../media/memory-problems-thinkgraph.msft.png" alt-text="Визуальное представление памяти" lightbox="../media/memory-problems-thinkgraph.msft.png":::
   Визуальное представление памяти  
:::image-end:::  

Объект может удерживать память двумя способами:  

*   Непосредственно по объекту.  
*   Неявно путем удержания ссылок на другие объекты и, следовательно, предотвращения автоматического утилизации этих объектов сборщиком мусора.  

При работе с панелью [памяти][DevtoolsMemoryProblemsHeapSnapshots] в DevTools \(средство для расследования проблем памяти, найденных в **Memory**\), вы можете найти себе, глядя на несколько различных столбцов информации.  Два, которые выделяются **являются Неглубокий размер** и **сохраненный**размер, но что они представляют?  

:::image type="complex" source="../media/memory-problems-shallow-retained.msft.png" alt-text="Неглубокий и сохраненный размер" lightbox="../media/memory-problems-shallow-retained.msft.png":::
   Неглубокий и сохраненный размер  
:::image-end:::  

### <a name="shallow-size"></a>Неглубокий размер  

Это размер памяти, удерживаемой объектом.  

Типичные объекты JavaScript имеют некоторую память, зарезервированную для их описания и для хранения немедленных значений.  Как правило, только массивы и строки могут иметь значительный неглубокий размер.  Однако строки и внешние массивы часто имеют основное хранилище в памяти отрисовщика, что создает только небольшой объект оболочки на кучи JavaScript.  

Память renderer — это вся память процесса, в котором отрисовка проинспектировали страницу: родной памяти + JS кучи памяти страницы + JS кучи памяти всех выделенных рабочих, запущенных на странице.  Тем не менее даже небольшой объект может удерживать большое количество памяти косвенно, предотвращая утилизацию других объектов с помощью автоматического процесса сбора мусора.  

### <a name="retained-size"></a>Сохраненный размер  

Это размер памяти, которая освободилась после удаления объекта вместе с зависимыми объектами, которые были недоступны из корней **коллектора мусора.**  

**Корневой сборщик** мусора **** состоит из дескрипторов, созданных \(локальный или глобальный\) при создании ссылки из родного кода на объект JavaScript за пределами V8.  Все такие ручки можно найти в снимке кучи в области **обработки**корней GC и  >  **** **корней GC**  >  **Global handles.**  Описание обработок в этой документации без погружения в детали реализации браузера может привести к путанице.  И корни коллектора мусора, и ручки не являются чем-то, о чем вам нужно беспокоиться.  

Существует множество внутренних корней сборщика мусора, большинство из которых не интересны пользователям.  С точки зрения приложений существуют следующие типы корней.  

*   Объект Window global \(в каждом iframe\).  В снимках кучи имеется поле расстояния, которое является числом ссылок свойств на самом коротком пути сохранения из окна.  
*   Дерево DOM документа, состоящее из всех родных узлов DOM, до которых можно добраться, обходя документ.  Не все узлы могут иметь Обертки JS, но если узел имеет оболочку, он жив, пока документ жив.  
*   Иногда объекты могут сохраняться контекстом отладки в панели **Источники** и консоли **** \(например, после оценки консоли\).  Создайте снимки кучи с помощью очищенной панели **консоли** и без активных точек взлома в отладке в панели **Источники.**

>[!TIP]
> Сними **панель Консоли,** задействуя и отключая точки разлома в панели Источники, прежде чем принимать снимок кучи `clear()` в панели [памяти.][DevtoolsMemoryProblemsHeapSnapshots] ****

Граф памяти начинается с корневого, который может быть объектом браузера или объектом `window` `Global` Node.js модуля.  Вы не контролируете, как этот корневой объект собирает мусор.  

:::image type="complex" source="../media/memory-problems-dontcontrol.msft.png" alt-text="Вы не можете контролировать, как собираются корневые объекты мусора." lightbox="../media/memory-problems-dontcontrol.msft.png":::
   Вы не можете контролировать, как собираются корневые объекты мусора.  
:::image-end:::  

Все, что невозможно получить из корневого корня, получает собранный мусор.  

> [!NOTE]
> Столбцы ["Мелкий размер"](#shallow-size) и ["Сохраненный](#retained-size) размер" представляют данные в bytes.  

## <a name="objects-retaining-tree"></a>Объекты, удерживающие дерево  

Куча — это сеть взаимосвязанных объектов.  В математическом мире эта структура называется **графом или** графиком памяти.  Граф строится из **узлов, подключенных** с помощью краев, **** оба из которых даются метки.  

*   **Узлы** \(или **объекты**\) помечены с помощью имени функции **конструктора,** которая использовалась для их создания.  
*   **Края помечены** с помощью имен **свойств.**  

Узнайте, [как записывать профиль с помощью профайла кучи.][DevtoolsMemoryProblemsHeapSnapshots]  На следующем рисунке некоторые заметные моментальные записи [][DevtoolsMemoryProblemsHeapSnapshots] в инструменте Памяти включают расстояние: расстояние до корневого коллектора мусора.  Если почти все объекты одного типа находятся на одном расстоянии, а некоторые находятся на более большом расстоянии, это то, что стоит и расследовать.  

:::image type="complex" source="../media/memory-problems-root.msft.png" alt-text="Расстояние от корневого" lightbox="../media/memory-problems-root.msft.png":::
   Расстояние от корневого  
:::image-end:::  

## <a name="dominators"></a>Dominators  

Объекты Dominator состоят из структуры дерева, так как каждый объект имеет точно один доминатор.  У доминатора объекта может не быть прямых ссылок на объект, в котором он доминирует; то есть дерево доминатора не является охватывающим деревом графа.  

На следующем рисунке верно следующее утверждение.  

*   Узел 1 доминирует над узлом 2  
*   Узел 2 доминирует над узлами 3, 4 и 6  
*   Узел 3 доминирует над узлом 5  
*   Узел 5 доминирует над узлом 8  
*   Узел 6 доминирует над узлом 7  

:::image type="complex" source="../media/memory-problems-dominatorsspanning.msft.png" alt-text="Структура дерева Dominator" lightbox="../media/memory-problems-dominatorsspanning.msft.png":::
   Структура дерева Dominator  
:::image-end:::  

На следующем рисунке узел является доминантом , но также существует в каждом простом пути `#3` `#10` от `#7` коллектора мусора до `#10` .  Таким образом, объект B является доминантом объекта A, если B существует в каждом простом пути от корневого к объекту A.  

:::image type="complex" source="../media/memory-problems-dominators.msft.gif" alt-text="Анимированные иллюстрации доминатора" lightbox="../media/memory-problems-dominators.msft.gif":::
   Анимированные иллюстрации доминатора  
:::image-end:::  

## <a name="v8-specifics"></a>Особенности V8  

При профилирование памяти полезно понять, почему снимки кучи выглядят определенным образом.  В этом разделе описываются некоторые темы, связанные с памятью, соответствующие виртуальной машине **V8 JavaScript** \(V8 VM или VM\).  

### <a name="javascript-object-representation"></a>Представление объектов JavaScript  

Существует три примитивных типа:  

*   Номера `3.14159...` \(например\)  
*   Booleans \( `true` или `false` \)  
*   Строки `"Werner Heisenberg"` \(например\)  

Примитивы не могут ссылаться на другие значения и всегда являются листами или завершающие узлы.  

**Номера** могут храниться так же:  

*   немедленные 31-битные значения, называемые небольшими дополнительными **значениями** \(**SMI**s\), или  
*   кучи объектов, именуемых **кучи номеров**. Кучи номера используются для хранения значений, не вписывающихся в форму SMI, таких как двойные **значения,** или когда значение должно быть в **поле,** например, параметр свойства на нем.  

**Строки** могут храниться в любом из них:  

*   куча **VM**или
*   внешне в **памяти отрисовщика**.  Объект **оболочки** создается и используется для доступа к внешнему хранилищу, где, например, хранятся источники скриптов и другой контент, полученный из Интернета, а не копируется на кучи VM.

Память для новых объектов JavaScript выделяется из выделенной кучи JavaScript \(или **Кучи VM\).**  Эти объекты управляются сборщиком мусора в V8 и, следовательно, остаются в живых до тех пор, пока существует по крайней мере одна сильная ссылка на них.  

Все, что не находится в кучи JavaScript, называется родным **объектом.**  Местные объекты, в отличие от объектов куча, не управляются сборщиком мусора V8 в течение всего срока службы и могут быть доступны только из JavaScript с помощью объекта оболочки JavaScript.  

**Строка "Минусы"** — это объект, состоящий из пар строк, которые хранятся и затем присоединяются, и является результатом конкатуации.  Присоединение содержимого **строки "против"** происходит только по мере необходимости.  Например, когда необходимо построить подстройку соединяемой строки.

Например, если вы одновременно и , вы получите `a` `b` `(a, b)` строку, которая представляет результат concatenation.  Если вы позже согласились с этим результатом, вы получите еще одну строку `d` **минусы**: `((a, b, d)` .  

**Массив** — это объект с числовых клавишами. **Массивы** широко используются в V8 VM для хранения больших объемов данных. Наборы пар значений ключей, например словари, имеют подстройки **массивами.**  

Типичный объект JavaScript хранится в качестве только одного из двух **типов массивов:**  

*   именуемые свойства и  
*   числимые элементы  

При небольшом количестве свойств свойства хранятся внутри объекта JavaScript.  

**Map** — это объект, который описывает как вид объекта, так и макет. Например, карты используются для описания неявных иерархий объектов для [быстрого доступа к свойствам.][V8FastProperties]  

### <a name="object-groups"></a>Группы объектов  

Каждая **группа родных** объектов состоит из объектов, которые содержат взаимные ссылки друг на друга.  Рассмотрим, например, подтрибую DOM, где каждый узел имеет ссылку на родственника и ссылки на следующего ребенка и следующего родственника, образуя, таким образом, связанный график.  

> [!NOTE]
> Коренные объекты не представлены в кучи JavaScript.  Отсутствие представления является причиной нулевого размера родных объектов. Вместо этого создаются объекты оболочки.  

Каждый объект оболочки содержит ссылку на соответствующий родной объект для перенаправления команд на него.  В свою очередь, объектная группа содержит объекты оболочки.  Однако это не создает непостижимый цикл, так как сборщик мусора достаточно умен, чтобы освободить объектные группы, обертки которых больше не ссылались.  Но забыв о выпуске одной обертки содержит всю группу и связанные обертки.  

## <a name="getting-in-touch-with-the-microsoft-edge-devtools-team"></a>Взаимодействие с командой средств разработчика Microsoft Edge  

[!INCLUDE [contact DevTools team note](../includes/contact-devtools-team-note.md)]  

<!-- links -->  

[DevtoolsMemoryProblemsHeapSnapshots]: ./heap-snapshots.md "Запись снимков кучи | Документы Майкрософт"  

[V8FastProperties]: https://v8.dev/blog/fast-properties "Быстрые свойства в V8 | V8"  

> [!NOTE]
> Некоторые части этой страницы представляют собой измененные материалы, созданные и [предоставленные корпорацией Google][GoogleSitePolicies]. Их использование регулируется условиями, описанными в [лицензии Creative Commons Attribution 4.0 International License][CCA4IL].  
> Оригинальная страница находится [здесь](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101) и является автором [Meggin Kearney][MegginKearney] \(Technical Writer\).  

[![Лицензия Creative Commons][CCby4Image]][CCA4IL]  
Эта работа предоставляется в рамках международной лицензии [Creative Commons Attribution 4.0 International License][CCA4IL].  

[CCA4IL]: https://creativecommons.org/licenses/by/4.0  
[CCby4Image]: https://i.creativecommons.org/l/by/4.0/88x31.png  
[GoogleSitePolicies]: https://developers.google.com/terms/site-policies  
[KayceBasques]: https://developers.google.com/web/resources/contributors/kaycebasques  
[MegginKearney]: https://developers.google.com/web/resources/contributors/megginkearney
