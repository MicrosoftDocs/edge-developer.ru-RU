---
description: Используйте механизм JavaScript, основанный на стандартах Chakra, для добавления возможностей сценария в приложение для Windows.
title: Размещение среды выполнения JavaScript | Документы Microsoft
ms.custom: ''
ms.date: 01/15/2020
ms.prod: microsoft-edge
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 30ec744e-57cc-4ef5-8fe1-d2c27b946548
caps.latest.revision: 14
author: MSEdgeTeam
ms.author: msedgedevrel
manager: ''
ms.openlocfilehash: 9077284d96ff0d9ae22e152329efe9304081ae39
ms.sourcegitcommit: 6860234c25a8be863b7f29a54838e78e120dbb62
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2020
ms.locfileid: "10571483"
---
# <span data-ttu-id="02581-103">Размещение среды выполнения JavaScript</span><span class="sxs-lookup"><span data-stu-id="02581-103">Hosting the JavaScript Runtime</span></span>
<span data-ttu-id="02581-104">API среды выполнения JavaScript (JsRT) обеспечивают способ добавления в приложение возможностей для настольных систем, магазина Windows и серверных приложений, работающих в операционной системе Windows, с помощью основанного на стандартах обработчика JavaScript Chakra, который также используется Microsoft EDGE и Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="02581-104">The JavaScript Runtime (JsRT) APIs provide a way for desktop, Windows Store, and server-side applications running on the Windows operating system to add scripting capabilities to the application by using the standards-based Chakra JavaScript engine that is also utilized by Microsoft Edge and Internet Explorer.</span></span> <span data-ttu-id="02581-105">Эти API-интерфейсы доступны в Windows 10 и в любой версии операционной системы Windows, в которой установлен Internet Explorer версии 11,0 на компьютере.</span><span class="sxs-lookup"><span data-stu-id="02581-105">These APIs are available on Windows 10 and any version of the Windows operating system that has Internet Explorer version 11.0 installed on the machine.</span></span> <span data-ttu-id="02581-106">Дополнительные сведения можно найти в статье [Справочник (среда выполнения JavaScript)](../chakra-hosting/reference-javascript-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="02581-106">For more info, see [Reference (JavaScript Runtime)](../chakra-hosting/reference-javascript-runtime.md).</span></span> <span data-ttu-id="02581-107">Сведения о том, как использовать JsRT в приложениях Магазина Windows, можно найти в статье [JsRT и универсальной платформы Windows](#Windows).</span><span class="sxs-lookup"><span data-stu-id="02581-107">For info on using the JsRT in Windows Store apps, see [JsRT and the Universal Windows Platform](#Windows).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02581-108">В этом документе предполагается, что вы знакомы с языком JavaScript.</span><span class="sxs-lookup"><span data-stu-id="02581-108">This documentation assumes a general working familiarity with the JavaScript language.</span></span>  
  
## <span data-ttu-id="02581-109">Понятия</span><span class="sxs-lookup"><span data-stu-id="02581-109">Concepts</span></span>  
 <span data-ttu-id="02581-110">Общие сведения о размещении обработчика JavaScript с помощью API JsRT зависит от двух ключевых концепций: среды выполнения и контексты выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-110">Understanding how to host the JavaScript engine using the JsRT APIs depends on two key concepts: runtimes and execution contexts.</span></span>  
  
 <span data-ttu-id="02581-111">*Среда выполнения* представляет полную среду выполнения JavaScript.</span><span class="sxs-lookup"><span data-stu-id="02581-111">A *runtime* represents a complete JavaScript execution environment.</span></span> <span data-ttu-id="02581-112">Каждая созданная среда выполнения имеет собственную изолированную кучу, собранную сборщиком мусора, и, по умолчанию, собственный поток JIT-компилятора и поток сборщика мусора (GC).</span><span class="sxs-lookup"><span data-stu-id="02581-112">Each runtime that is created has its own isolated garbage collected heap and, by default, its own just-in-time (JIT) compiler thread and garbage collector (GC) thread.</span></span> <span data-ttu-id="02581-113">*Контекст выполнения* представляет среду JavaScript, у которой есть собственный глобальный объект JavaScript, отличный от всех других контекстов выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-113">An *execution context* represents a JavaScript environment that has its own JavaScript global object distinct from all other execution contexts.</span></span> <span data-ttu-id="02581-114">Одна среда выполнения может содержать несколько контекстов выполнения, и в таких случаях все контексты выполнения совместно содержат JIT-компилятор и поток GC, связанный со средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-114">One runtime may contain multiple execution contexts, and in such cases, all the execution contexts share the JIT compiler and GC thread associated with the runtime.</span></span>  
  
 <span data-ttu-id="02581-115">Среды выполнения представляют собой один поток выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-115">Runtimes represent a single thread of execution.</span></span> <span data-ttu-id="02581-116">Только одна среда выполнения может быть активна в конкретном потоке в каждый момент времени, и среда выполнения может быть активна только в одном потоке.</span><span class="sxs-lookup"><span data-stu-id="02581-116">Only one runtime can be active on a particular thread at a time, and a runtime can only be active on one thread at a time.</span></span> <span data-ttu-id="02581-117">Среда выполнения является потоком аренды, поэтому среда выполнения, которая не активна в данный момент в потоке (например, не выполняется ни один из кодов JavaScript или не отвечает на звонки из хоста), может использоваться в любом потоке, у которого еще нет активной среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-117">Runtimes are rental threaded, so a runtime that is not currently active on a thread (i.e. isn't running any JavaScript code or responding to any calls from the host) can be used on any thread that doesn't already have an active runtime on it.</span></span>  
  
 <span data-ttu-id="02581-118">Контексты выполнения связаны с определенной средой выполнения и исполняемым кодом в этой среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-118">Execution contexts are tied to a particular runtime and execute code within that runtime.</span></span> <span data-ttu-id="02581-119">В отличие от сред выполнения, несколько контекстов выполнения могут быть активными в потоке одновременно.</span><span class="sxs-lookup"><span data-stu-id="02581-119">Unlike runtimes, multiple execution contexts can be active on a thread at the same time.</span></span> <span data-ttu-id="02581-120">Так что ведущее приложение может вызвать контекст выполнения, так как этот контекст выполнения может вызвать метод на хосте, и хост может сделать вызов в другой контекст выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-120">So a host can make a call into an execution context, that execution context can call back to the host, and the host can make a call into a different execution context.</span></span>  
  
 ![Несколько контекстов выполнения](../chakra-hosting/media/js-chakra-hosting.png "JS_Chakra_Hosting")  
  
 <span data-ttu-id="02581-122">На практике вы можете использовать один контекст выполнения, если только хосту не требуется выполнять код в раздельных средах.</span><span class="sxs-lookup"><span data-stu-id="02581-122">In practice, unless a host needs to run code in separated environments, a single execution context can be used.</span></span> <span data-ttu-id="02581-123">Точно так же, если хост не должен одновременно работать с несколькими фрагментами кода, достаточно одной среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-123">Similarly, unless a host needs to run multiple pieces of code concurrently, a single runtime is sufficient.</span></span>  
  
## <span data-ttu-id="02581-124">Управление памятью</span><span class="sxs-lookup"><span data-stu-id="02581-124">Memory management</span></span>  
 <span data-ttu-id="02581-125">JavaScript — это язык сборки мусора, поэтому есть несколько моментов, которые необходимо учитывать при работе с API JsRT на другом языке.</span><span class="sxs-lookup"><span data-stu-id="02581-125">JavaScript is a garbage collected language, and thus there are several considerations that must be kept in mind when working with the JsRT APIs from another language.</span></span>  
  
 <span data-ttu-id="02581-126">Основной вопрос состоит в том, что сборщик мусора JavaScript может видеть только ссылки на значения в двух местах: из кучи среды выполнения и стека.</span><span class="sxs-lookup"><span data-stu-id="02581-126">The main consideration is that the JavaScript garbage collector can only see references to values in two places: its runtime's heap, and the stack.</span></span> <span data-ttu-id="02581-127">Таким образом, ссылка на значение JavaScript, которое хранится в другом значении JavaScript или в локальной переменной в стеке, всегда будет отображаться сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="02581-127">Thus, a reference to a JavaScript value that is stored inside of another JavaScript value or in a local variable on the stack will always be seen by the garbage collector.</span></span> <span data-ttu-id="02581-128">Однако ссылки, хранящиеся в других расположениях, таких как кучи, управляемые ведущим приложением или системой, не будут рассматриваться сборщиком мусора и могут привести к преждевременному сбору значений, которые по-прежнему используются узлом.</span><span class="sxs-lookup"><span data-stu-id="02581-128">But references stored in other locations, such as heaps managed by the host or the system, will not be seen by the garbage collector and may result in premature collection of values that are still in use by the host.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="02581-129">Некоторые языковые компиляторы (такие как компилятор Visual Studio C++) будут оптимизировать локальные переменные, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="02581-129">Some language compilers (such as the Visual Studio C++ compiler) will optimize away local variables where possible.</span></span> <span data-ttu-id="02581-130">Будьте внимательны, чтобы убедиться в том, что локальные переменные, ссылающиеся на значения JavaScript, находятся в стеке, если предполагается, что они должны поддерживать активность этих значений.</span><span class="sxs-lookup"><span data-stu-id="02581-130">Care must be taken to ensure that local variables that reference JavaScript values are on the stack if they are expected to keep those values alive.</span></span>  
  
 <span data-ttu-id="02581-131">Если ссылка на значение JavaScript будет храниться в расположении, невидимом для сборщика мусора, ведущее приложение должно вручную добавить и удалить ссылки с помощью API JsRT.</span><span class="sxs-lookup"><span data-stu-id="02581-131">If a reference to a JavaScript value will be stored in a location not visible to the garbage collector, the host must manually add and remove references using the JsRT APIs.</span></span>  
  
## <span data-ttu-id="02581-132">Обработка исключений</span><span class="sxs-lookup"><span data-stu-id="02581-132">Exception handling</span></span>  
 <span data-ttu-id="02581-133">При возникновении исключения JavaScript во время выполнения сценария содержащаяся среда выполнения помещается в состояние исключения.</span><span class="sxs-lookup"><span data-stu-id="02581-133">When a JavaScript exception occurs during script execution, the containing runtime is put into an exception state.</span></span> <span data-ttu-id="02581-134">В состоянии исключения код не может выполняться, и все вызовы API завершатся сбоем с кодом ошибки, `JsErrorInExceptionState` пока хост не извлекает и не очищает исключение с помощью `JsGetAndClearException` API.</span><span class="sxs-lookup"><span data-stu-id="02581-134">While in an exception state, no code can run and all API calls will fail with the error code `JsErrorInExceptionState` until the host retrieves and clears the exception using the `JsGetAndClearException` API.</span></span> <span data-ttu-id="02581-135">Если ведущее приложение возвращается из обратного вызова JavaScript, но не очищает среду выполнения из состояния исключения, то после того как управление передается обратно в обработчик JavaScript, будет выдано повторное создание исключения JavaScript.</span><span class="sxs-lookup"><span data-stu-id="02581-135">If the host returns from a JavaScript callback without clearing the runtime from an exception state, then the JavaScript exception will be re-thrown as soon as control passes back to the JavaScript engine.</span></span> <span data-ttu-id="02581-136">Это также позволяет обратным вызовам узла "выдавать" исключение JavaScript, задавая среду выполнения в состояние исключения и возвращая ее из обратного вызова хоста.</span><span class="sxs-lookup"><span data-stu-id="02581-136">This also enables host callbacks to "throw" a JavaScript exception by setting the runtime into an exception state and then returning from a host callback.</span></span>  
  
 <span data-ttu-id="02581-137">Ведущему приложению не разрешается разрешать своим внутренним исключениям распространяться по обратному вызову узла — любые методы обратного вызова должны перехватывать все исключения хоста, прежде чем возвращать управление среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-137">A host is not allowed to let its own internal exceptions to propagate across a host callback—any callback methods must catch all host exceptions before returning control to the runtime.</span></span>  
  
## <span data-ttu-id="02581-138">Использование ресурсов среды выполнения</span><span class="sxs-lookup"><span data-stu-id="02581-138">Runtime resource usage</span></span>  
 <span data-ttu-id="02581-139">API JsRT предоставляют ряд способов мониторинга и изменения способа использования ресурсов средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-139">The JsRT APIs expose a number of way to monitor and modify the way runtimes use resources.</span></span> <span data-ttu-id="02581-140">Как правило, они разбиваются на следующие категории:</span><span class="sxs-lookup"><span data-stu-id="02581-140">They generally break down into the following categories:</span></span>  
  
-   <span data-ttu-id="02581-141">**Использование потоков**.</span><span class="sxs-lookup"><span data-stu-id="02581-141">**Thread Usage**.</span></span> <span data-ttu-id="02581-142">По умолчанию каждый из сред выполнения создаст выделенный поток JIT-компилятора и выделенный поток GC, обслуживающий эту среду выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-142">By default, each runtime will create a dedicated JIT compiler thread and a dedicated GC thread that service that runtime.</span></span> <span data-ttu-id="02581-143">Если среда выполнения создана с `JsRuntimeAttributeDisableBackgroundWork` флагом, то для каждого из них будет выполняться процесс JIT и GC, а не отдельные фоновые потоки.</span><span class="sxs-lookup"><span data-stu-id="02581-143">If a runtime is created with the `JsRuntimeAttributeDisableBackgroundWork` flag, then the JIT and GC work will be performed on the runtime thread itself instead of separate background threads for each one of them.</span></span> <span data-ttu-id="02581-144">Ведущее приложение может также предоставлять вызов службы потока обратного вызова `JsCreateRuntime` , что позволяет основному приложению планировать работу JIT-и GC в любом направлении.</span><span class="sxs-lookup"><span data-stu-id="02581-144">A host can also supply a thread service callback to the `JsCreateRuntime` call, which will allow the host to schedule JIT and GC work in any way it sees fit.</span></span>  
  
-   <span data-ttu-id="02581-145">**Использование памяти**.</span><span class="sxs-lookup"><span data-stu-id="02581-145">**Memory Usage**.</span></span> <span data-ttu-id="02581-146">Существует несколько способов мониторинга и изменения использования памяти средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-146">There are several ways to monitor and modify the memory usage of a runtime.</span></span> <span data-ttu-id="02581-147">Если среда выполнения будет выполняться в течение длительного времени, ведущее приложение может задать `JsRuntimeAttributeEnableIdleProcessing` флаг при создании среды выполнения, а затем вызвать, `JsIdle` когда узел находится в состоянии простоя.</span><span class="sxs-lookup"><span data-stu-id="02581-147">If the runtime will be running for a long time, the host can specify the `JsRuntimeAttributeEnableIdleProcessing` flag when creating the runtime and then call `JsIdle` when the host is in an idle state.</span></span> <span data-ttu-id="02581-148">Это позволяет подсистеме откладывать некоторые операции очистки памяти и бухгалтерского учета, пока не будет определено время простоя.</span><span class="sxs-lookup"><span data-stu-id="02581-148">This allows the engine to defer some memory cleanup and bookkeeping work until idle time.</span></span>  
  
     <span data-ttu-id="02581-149">Основное приложение может отслеживать сбор мусора с помощью вызова `JsSetRuntimeBeforeCollectCallback` .</span><span class="sxs-lookup"><span data-stu-id="02581-149">The host can monitor garbage collections by calling `JsSetRuntimeBeforeCollectCallback`.</span></span> <span data-ttu-id="02581-150">Кроме того, он может отслеживать выделение памяти, сделанных кучей, вызывая `JsSetRuntimeMemoryAllocationCallback` .</span><span class="sxs-lookup"><span data-stu-id="02581-150">It can also monitor allocations made by the heap by calling `JsSetRuntimeMemoryAllocationCallback`.</span></span> <span data-ttu-id="02581-151">Обратите внимание, что этот API не вызывает обратно для каждого выделения JavaScript, просто когда для кучи среды выполнения потребуется больше места для выделения.</span><span class="sxs-lookup"><span data-stu-id="02581-151">Note that this API does not call back on every JavaScript allocation, just when the runtime's heap needs more space from which to allocate.</span></span> <span data-ttu-id="02581-152">Обратный вызов выделения памяти может отклонить запрос, что приводит к инициированию сборки мусора и, если объем памяти недоступен, в среде выполнения возникает ошибка "недостаточно памяти".</span><span class="sxs-lookup"><span data-stu-id="02581-152">The memory allocation callback is allowed to deny the request, which will trigger a garbage collection and, if no memory is available, an out of memory error in the runtime.</span></span>  
  
     <span data-ttu-id="02581-153">Основное приложение также может вызвать `JsSetRuntimeMemoryLimit` для установки ограничения объема памяти, который может использовать среда выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-153">The host can also call `JsSetRuntimeMemoryLimit` to set a limit for how much memory a runtime can use.</span></span> <span data-ttu-id="02581-154">Если среда выполнения достигает предельного значения, она инициирует сборку мусора и, если память не доступна, среда выполнения вызывает ошибку нехватки памяти.</span><span class="sxs-lookup"><span data-stu-id="02581-154">When a runtime hits a limit, it will trigger a garbage collection and, if no memory is available, an out of memory error will be thrown by the runtime.</span></span>  
  
-   <span data-ttu-id="02581-155">**Прерывание и оценку сценария**.</span><span class="sxs-lookup"><span data-stu-id="02581-155">**Script Interruption and Evaluation**.</span></span> <span data-ttu-id="02581-156">Основное приложение может вызвать `JsDisableRuntimeExecution` прекращение выполнения в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="02581-156">The host can call `JsDisableRuntimeExecution` to terminate execution within a runtime.</span></span> <span data-ttu-id="02581-157">Этот звонок можно выполнить в любое время и из любого потока.</span><span class="sxs-lookup"><span data-stu-id="02581-157">This call can be made at any time and from any thread.</span></span> <span data-ttu-id="02581-158">Так как завершение сценария зависит от того, какие точки защиты вставляются в код, сценарий может не завершиться в течение определенного времени, но вскоре позже.</span><span class="sxs-lookup"><span data-stu-id="02581-158">Because script termination depends on reaching guard points inserted into the code, a script may not terminate at the exact moment, but will do so very shortly afterwards.</span></span> <span data-ttu-id="02581-159">По умолчанию контрольные точки увольнения размещаются в созданном коде и могут не охватывать все ситуации, например бесконечный цикл.</span><span class="sxs-lookup"><span data-stu-id="02581-159">By default, termination guard points are placed in the generated code conservatively and may not cover every situation, such as an infinite loop.</span></span> <span data-ttu-id="02581-160">Создание среды выполнения с помощью `JsRuntimeAttributeAllowScriptInterrupt` флага приводит к тому, что среда выполнения будет вставлять дополнительные проверки для бесконечного цикла, часто за счет небольшого объема производительности.</span><span class="sxs-lookup"><span data-stu-id="02581-160">Creating the runtime with the `JsRuntimeAttributeAllowScriptInterrupt` flag causes the runtime to insert additional checks for infinite loops, often at the cost of a small performance overhead.</span></span>  
  
     <span data-ttu-id="02581-161">Если основное приложение не может запретить создание машинного кода с помощью JIT-компилятора, можно задать `JsRuntimeAttributeDisableNativeCodeGeneration` флаг.</span><span class="sxs-lookup"><span data-stu-id="02581-161">If a host wishes to disallow generation of native code by the JIT compiler, it can specify the `JsRuntimeAttributeDisableNativeCodeGeneration` flag.</span></span> <span data-ttu-id="02581-162">Кроме того, узел может запретить выполнение сценариев с динамическим запуском сценариев, указав `JsRuntimeAttributeDisableEval` флаг.</span><span class="sxs-lookup"><span data-stu-id="02581-162">A host can also disallow scripts from dynamically running scripts itself by specifying the `JsRuntimeAttributeDisableEval` flag.</span></span>  
  
## <span data-ttu-id="02581-163">Отладка и профилирование</span><span class="sxs-lookup"><span data-stu-id="02581-163">Debugging and Profiling</span></span>  
 <span data-ttu-id="02581-164">API JsRT поддерживает отладку и профилирование с помощью активной технологии сценариев.</span><span class="sxs-lookup"><span data-stu-id="02581-164">JsRT APIs supports debugging and profiling via the Active Scripting technology.</span></span>  
  
 <span data-ttu-id="02581-165">Начиная с Windows 10, обработчик JavaScript Chakra поддерживает устаревший обработчик Internet Explorer (MSHTML) и новый обработчик Microsoft EDGE (EdgeHTML), и вы можете ориентироваться в JsRT (Дополнительные сведения можно найти в разделе [Настройка Microsoft EDGE и устаревшие ядра](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md) ).</span><span class="sxs-lookup"><span data-stu-id="02581-165">Starting in Windows 10, the Chakra JavaScript Engine supports the legacy Internet Explorer (MSHTML) engine and new Microsoft Edge (EdgeHTML) engine, and you can target either in JsRT (see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md) for details).</span></span> <span data-ttu-id="02581-166">Отладка сценария в Visual Studio работает не так, как в старом обработчике и Microsoft Edge.</span><span class="sxs-lookup"><span data-stu-id="02581-166">Debugging a script in Visual Studio works differently between the legacy engine and Microsoft Edge engine.</span></span> <span data-ttu-id="02581-167">С помощью устаревшего модуля хост должен предоставить указатель [интерфейса IDebugApplication](/scripting/winscript/reference/idebugapplication-interface) , который можно получить из экземпляра [интерфейса IProcessDebugManager](/scripting/winscript/reference/iprocessdebugmanager-interface) .</span><span class="sxs-lookup"><span data-stu-id="02581-167">With the legacy engine, the host needs to provide an [IDebugApplication Interface](/scripting/winscript/reference/idebugapplication-interface) pointer, which can be obtained from an [IProcessDebugManager Interface](/scripting/winscript/reference/iprocessdebugmanager-interface) instance.</span></span> <span data-ttu-id="02581-168">С помощью подсистемы Microsoft Edge `IDebugApplication` является устаревшим, а подсистема Chakra поддерживает возможности отладки в собственном и пользовательском интерфейсе с помощью отладчика Visual Studio, не требуя `IDebugApplication` от него реализации.</span><span class="sxs-lookup"><span data-stu-id="02581-168">With the Microsoft Edge engine, `IDebugApplication` is deprecated, and the Chakra engine enables native and script debugging capabilities through the Visual Studio debugger without requiring an implementation of `IDebugApplication` from the user.</span></span>  
  
 <span data-ttu-id="02581-169">Чтобы скрипты в контекстах выполнения были отлаженными, обработчику Chakra нужно переключиться на использование менее эффективных методов выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="02581-169">To make scripts in an execution context debuggable, the Chakra engine has to switch to using less efficient code execution methods.</span></span> <span data-ttu-id="02581-170">Таким образом, отлаживаемый код обычно работает медленнее, чем неотлаживаемый код.</span><span class="sxs-lookup"><span data-stu-id="02581-170">As such, debuggable code typically runs slower than non-debuggable code.</span></span> <span data-ttu-id="02581-171">В результате с помощью устаревшего модуля хост может либо запустить отладку в контексте выполнения с начала, добавив `IDebugApplication` указатель вверх `JsCreateContext` , либо подождать, пока требуется отладка, а затем вызвать `JsStartDebugging` .</span><span class="sxs-lookup"><span data-stu-id="02581-171">As a result, with the legacy engine, a host can choose to either start debugging in an execution context from the beginning by providing the `IDebugApplication` pointer up front through `JsCreateContext`, or it can wait until debugging is needed and then call `JsStartDebugging`.</span></span> <span data-ttu-id="02581-172">С помощью подсистемы Microsoft Edge `JsCreateContext` больше не принимает `IDebugApplication` параметр, и в результате сценарий будет отлажен только после `JsStartDebugging` вызова.</span><span class="sxs-lookup"><span data-stu-id="02581-172">With the Microsoft Edge engine, `JsCreateContext` no longer takes an `IDebugApplication` parameter, and as a result the script is debuggable only after `JsStartDebugging` is called.</span></span> <span data-ttu-id="02581-173">При отладке с использованием Visual Studio параметр отладчика "сценарии" должен быть включен.</span><span class="sxs-lookup"><span data-stu-id="02581-173">When debugging using Visual Studio, the "Script" debugger option must be enabled.</span></span>  
  
 <span data-ttu-id="02581-174">Код JavaScript в контексте выполнения может быть профилировщиком одним из двух способов.</span><span class="sxs-lookup"><span data-stu-id="02581-174">The JavaScript code in an execution context can be profiled in one of two ways.</span></span> <span data-ttu-id="02581-175">Профилировщик Visual Studio (VSPerf. exe) командной строки можно использовать в Windows 8,1 и более поздних версиях с помощью переключателя/JS для создания отчета, предназначенного для выполнения кода JavaScript в приложении.</span><span class="sxs-lookup"><span data-stu-id="02581-175">The command line Visual Studio Profiler (vsperf.exe) can be used in Windows 8.1 and later versions with the /js switch to produce a report that targets the JavaScript code run in the application.</span></span> <span data-ttu-id="02581-176">Кроме того, хост может напрямую вызывать метод `JsStartProfiling` и `JsStopProfiling` обеспечивать обратный вызов для самостоятельного профилирования.</span><span class="sxs-lookup"><span data-stu-id="02581-176">Or the host can directly call `JsStartProfiling` and `JsStopProfiling` and provide a callback to do profiling itself.</span></span> <span data-ttu-id="02581-177">Ведущее приложение может также проверять состояние кучи, в которой собрано мусора, путем вызова `JsEnumerateHeap` .</span><span class="sxs-lookup"><span data-stu-id="02581-177">The host can also examine the state of the garbage collected heap by calling `JsEnumerateHeap`.</span></span> <span data-ttu-id="02581-178">Профилирование в JsRT работает таким же образом, как и для старой версии, и для ядра Microsoft Edge.</span><span class="sxs-lookup"><span data-stu-id="02581-178">Profiling in JsRT works in the same manner between the legacy and the Microsoft Edge engine.</span></span> <span data-ttu-id="02581-179">Однако JsRT API профилирования (, `JsStartProfiling` `JsStopProfiling` , `JsEnumerateHeap` и) недоступны `JsIsEnumeratingHeap` для универсальных приложений для Windows.</span><span class="sxs-lookup"><span data-stu-id="02581-179">However, JsRT profiling APIs (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap`) are not available for Universal Windows Apps.</span></span>  
  
<a name="Windows"></a>   
## <span data-ttu-id="02581-180">JsRT и универсальная платформа Windows</span><span class="sxs-lookup"><span data-stu-id="02581-180">JsRT and the Universal Windows Platform</span></span>  

<span data-ttu-id="02581-181">Вы можете использовать API JsRT для добавления возможностей сценария в универсальное приложение для Windows.</span><span class="sxs-lookup"><span data-stu-id="02581-181">You can use JsRT APIs to add scripting capabilities to a Universal Windows app.</span></span> <span data-ttu-id="02581-182">Универсальное приложение для Windows, использующее API JsRT, должно нацелиться на API Microsoft Edge JSRT, которые, в свою очередь, предназначены для обработчика Chakra Edge.</span><span class="sxs-lookup"><span data-stu-id="02581-182">A Universal Windows app that uses the JsRT APIs will need to target the Microsoft Edge JSRT APIs, which in turn target the Edge Chakra engine.</span></span> <span data-ttu-id="02581-183">Дополнительные сведения можно найти в разделе [назначение Microsoft EDGE и устаревших ядер](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md).</span><span class="sxs-lookup"><span data-stu-id="02581-183">For more information, see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md).</span></span> <span data-ttu-id="02581-184">Полный API JsRT доступен для универсальных приложений для Windows, за исключением случаев, когда поддерживается профилирование и перечисление кучи ( `JsStartProfiling` , `JsStopProfiling` `JsEnumerateHeap` и `JsIsEnumeratingHeap` не поддерживается).</span><span class="sxs-lookup"><span data-stu-id="02581-184">The complete JsRT API is available for Universal Windows apps, except for profiling and heap enumeration support (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap` are not supported).</span></span>  
  
<span data-ttu-id="02581-185">JsRT также позволяет сценариям осуществлять собственный доступ к любым [API универсальной платформы Windows (UWP)](https://msdn.microsoft.com/library/windows/apps/br211377.aspx) после предоставления пространства имен API через API Microsoft Edge JsRT `JsProjectWinRTNamespace` .</span><span class="sxs-lookup"><span data-stu-id="02581-185">JsRT also allows scripts to natively access any [Universal Windows Platform (UWP) APIs](https://msdn.microsoft.com/library/windows/apps/br211377.aspx) after exposing the API namespace through Microsoft Edge JsRT API `JsProjectWinRTNamespace`.</span></span> <span data-ttu-id="02581-186">Несмотря на то, что для универсальных приложений для Windows не требуется настройка, помимо проецирования необходимых пространств имен, в классическом приложении Windows (Win32) необходимо включить механизм перебора, инициализированный COM, чтобы `JsSetProjectionEnqueueCallback` включить события и асинхронные API.</span><span class="sxs-lookup"><span data-stu-id="02581-186">While Universal Windows Applications require no setup in addition to projecting necessary namespaces, in a Classic (Win32) Windows Application, a COM-initialized delegated pumping mechanism needs to be enabled through `JsSetProjectionEnqueueCallback` to enable events and asynchronous APIs.</span></span> <span data-ttu-id="02581-187">В следующем примере Win32 используются асинхронные API UWP, чтобы создать HTTP-клиент для получения содержимого из универсального кода ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="02581-187">The following Win32 sample utilizes asynchronous UWP APIs to create an http client to get content from a Uri:</span></span>  
  
```cpp  
typedef struct _jsCall {  
    JsProjectionCallback jsCallback;  
    JsProjectionCallbackContext jsContext;  
    HANDLE event;  
} jsCall;  
  
// Set up delegated pumping mechanism; not necessary in UWP applications.  
jsCall outstandingCall = {};  
CoInitializeEx(nullptr, COINIT_MULTITHREADED);  
JsSetProjectionEnqueueCallback([](JsProjectionCallback jsCallback,   
JsProjectionCallbackContext jsContext, void *callbackState) {  
    jsCall* call = (jsCall*)callbackState;  
    call->jsCallback = jsCallback;  
    call->jsContext = jsContext;  
    SetEvent(call->event);  
    },  
&outstandingCall);  
HANDLE event = CreateEventEx(NULL, NULL, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);  
outstandingCall.event = event;  
  
// Project necessary namespaces.  
JsProjectWinRTNamespace(L"Windows.Foundation");  
JsProjectWinRTNamespace(L"Windows.Web");  
  
// Get content from an Uri.  
JsRunScript(L"var uri = new Windows.Foundation.Uri(\"http://somedatasource.com\"); " \  
    L"var httpClient = new Windows.Web.Http.HttpClient();" \  
    L"httpClient.getStringAsync(uri).done(function (content) { " \  
    L"    // do something with the string content " \    
    L"}, onError); " \  
    L"function onError(reason) { " \  
    L"    // error handling " \        
    L"}",   
    currentSourceContext, L"", &result);  
  
// Wait for async call to come in and then execute; not necessary in UWP applications.  
WaitForSingleObjectEx(outstandingCall.event, 10000, FALSE) == WAIT_OBJECT_0;  
outstandingCall.jsCallback(outstandingCall.jsContext);  
  
```  
  
## <span data-ttu-id="02581-188">См. также</span><span class="sxs-lookup"><span data-stu-id="02581-188">See Also</span></span>  
 [<span data-ttu-id="02581-189">Пример приложения среды выполнения JavaScript</span><span class="sxs-lookup"><span data-stu-id="02581-189">JavaScript Runtime Sample App</span></span>](https://go.microsoft.com/fwlink/p/?LinkID=306674&clcid=0x409)   
 [<span data-ttu-id="02581-190">Справочник (среда выполнения JavaScript)</span><span class="sxs-lookup"><span data-stu-id="02581-190">Reference (JavaScript Runtime)</span></span>](../chakra-hosting/reference-javascript-runtime.md)   
 [<span data-ttu-id="02581-191">Размещение среды выполнения JavaScript</span><span class="sxs-lookup"><span data-stu-id="02581-191">JavaScript Runtime Hosting</span></span>](../javascript-runtime-hosting.md)  
 